// Class automatically generated by Dev-C++ New Class wizard

#include "treap.h" 
#include <iostream>

#ifndef NULL
#define NULL 0
#endif

Treap::Treap()
{
	this->root = NULL;
}

// class destructor
Treap::~Treap()
{
	cout << "y muriooo";
}
//========GETTERS & SETTERS=============
BinNode* Treap::getRoot()
{ return this->root; }
//======================================

void Treap::Insert(BinNode* head, string key, string value, int priority, BinNode* papaDeHead, bool isLeftSon) //en head entregar root al principio de la recursion y en papa NULL
{
     //cout << endl<<"insertando nuevo"<<endl;
     //cout << "el head esta en :" << head <<endl;
     
     if(head == NULL)
     {
             
             head = new BinNode(key, value, papaDeHead, isLeftSon);
             //cout<<"head era nulo!, agregando al nodo de key: "<< key<<endl;
             head->TreapPriority = priority;
             
             if(papaDeHead == NULL)
                           root=head;
             //cout <<"dir de root:"<<root<<endl;
             return;
     }
     
     if(key.compare(head->getKey()) < 0)
     {
        //cout<<"vamos pal izq! dir de head: "<<head<<endl;
        Insert(head->Son(true), key, value, priority, head, true);
        if(head->Son(true)->TreapPriority > head->TreapPriority) {rotateRight(head);}
     }
     
     else if(key.compare(head->getKey())>0) 
     {
          //cout<<"vamos pa la der! dir de head:"<<head<<endl;
          Insert(head->Son(false), key, value, priority, head, false);
          if(head->Son(false)->TreapPriority > head->TreapPriority) {rotateLeft(head);}
     }
      
}



//==============ROTACIONES====================
void Treap::rotateRight(BinNode* head)
{
                                       
     //cout << "prioridad mayor en hijo izquierdo, se va a rotar derecha"<<endl;
     BinNode* top = head->Father();
     BinNode* c = head->Son(false);
     BinNode* lsArrow = head->Son(true); //left son arrow
     BinNode* a = lsArrow->Son(true);
     BinNode* b = lsArrow->Son(false);
     
     
     lsArrow->setSon(false, head);    
     lsArrow->setSon(true, a);
     head->setSon(false, c);
     head->setSon(true, b);
     
     if(top == NULL)
     {
            lsArrow->setFather(NULL);
            root = lsArrow;
     }
     else if(top->Son(false) == head)
     {top->setSon(false, lsArrow);}
     else top->setSon(true, lsArrow);  
               
}

void Treap::rotateLeft(BinNode* head)
{
     //cout <<"prioridad mayor en hijo derecho, se va a rotar izquierda"<<endl;
     BinNode* top = head->Father();
     BinNode* a = head->Son(true);
     BinNode* rsArrow = head->Son(false); //right son arrow
     BinNode* b = rsArrow->Son(true);
     BinNode* c = rsArrow->Son(false);
     
     rsArrow->setSon(false, c);
     rsArrow->setSon(true, head);   
     //if(b!=NULL)
     head->setSon(false, b);
     //if(a!=NULL)
     head->setSon(true, a);
     //lsArrow->setSon(false, alpha) no es necesario, alpha ya es hijo izquierdo de LS
     
     if(top == NULL)
     {
            rsArrow->setFather(NULL);
            root = rsArrow;
     }
     else if(top->Son(false) == head)
     {top->setSon(false, rsArrow);}
     else top->setSon(true, rsArrow);        
}

//================FIN ROTACIONES======================



void Treap::Delete(BinNode* head, string Key)
{
     if(head == NULL)
     {
             cout << "No se encontro un nodo con la clave buscada"<<endl;
             return;       
     }
     
     //cout << head->getKey() << "   " << Key << "   " <<Key.compare(head->getKey()) << "  " <<Key.compare(head->getKey())<< endl; 
     
     if(Key.compare(head->getKey()) > 0)
     { Delete(head->Son(false), Key);}
     else if(Key.compare(head->getKey()) < 0)
     { Delete(head->Son(true), Key);}
     else {/* cout << "entrando a eliminar " <<head->getKey()<<endl;*/ finalDelete(head);}
}

void Treap::finalDelete(BinNode* target)
{ 
  if(target==NULL)
  {
                  cout<<"FAILLLLL"<<endl;
                  return;  
  }   
     
  if(target->Son(true)==NULL && target->Son(false)==NULL) // true si es hoja
  {     
        if(target->Father() !=NULL) //el caso en que se da el father null: nodo root
        {
            if(target->Father()->Son(true) == target) 
            {target->Father()->setSon(true, NULL);}
            else { target->Father()->setSon(false, NULL); }
       
        }
        else root = NULL;
        
        //cout<< "eliminando " << target->getKey()<<endl;
        delete target; 
        return; 
  }
  
  else if(target->Son(true) == NULL)
  {
       rotateLeft(target);
       finalDelete(target);
  } 
  
  else if(target->Son(false) == NULL) 
  { 
       rotateRight(target); 
       finalDelete(target); 
  }
  else if(target->Son(true)->TreapPriority > target->Son(false)->TreapPriority)
  {
       rotateRight(target);
       finalDelete(target);
  } 
  
  else
  {
       rotateLeft(target);
       finalDelete(target);
  }
}



     
     



//====PRINT========
string Treap::PrettyPrint(BinNode* node, string Constant)
{
     string tmp= "";
     if(node->Son(false)!=NULL)
     tmp+=PrettyPrint(node->Son(false),"");
     tmp+=PrettyHelp(root,node,"");
     if(node->Son(true)!=NULL)
     tmp+=PrettyPrint(node->Son(true),"");
     /*if(node->Son(false)!=NULL)
     tmp+=PrettyPrint(node->Son(false),Constant+"\t\t|");
     tmp+=Constant + "--" + node->getKey() + "\n";
     if(node->Son(true)!=NULL)
     tmp+=PrettyPrint(node->Son(true),Constant+"\t\t|");*/
     return tmp;
}

string Treap::PrettyHelp(BinNode* From, BinNode* To, string Constant)
{
       int tmp=To->prettyOrder;
       if(To->getKey().compare(From->getKey())>0) //Está a la derecha del nodo
       {
             int tmp1=From->Son(false)->prettyOrder;
             if(tmp1>tmp)
             return PrettyHelp(From->Son(false),To,Constant+"\t\t\t");
             else
             return PrettyHelp(From->Son(false),To,Constant+"\t\t\t|");
       }
       else if(To->getKey().compare(From->getKey())<0)
       {
             int tmp1=From->Son(true)->prettyOrder;
             if(tmp1<tmp)
             return PrettyHelp(From->Son(true),To,Constant+"\t\t\t");
             else
             return PrettyHelp(From->Son(true),To,Constant+"\t\t\t|");
       }
       else
       {
           return Constant+"--" + To->getKey() + "\n";
       }
}

string Treap::PrettyPrint()
{
     //cout<<"raiz: "<<root<<endl;//wtf!!!!! se cae el a3 si pongo esto? :S
     //cout<<"el valor del puntero y el key del root en este treap es: "<<root<<" "<<endl; 
     //cout <<"imprimiendo treap"<<endl;
     RefreshPrettyOrder(root,1);
     return PrettyPrint(root,"");
 }
 
int Treap::RefreshPrettyOrder(BinNode* node, int Value)
{
    int tmp=Value;
    
    ////////////////////////////////////////////
    /*cout << "nodo que viene: " << node->getKey() << " hijos: "; 
    
    if(node->Son(true)!= NULL && node->Son(false) != NULL)
    cout <<node->Son(true)->getKey()<<" " <<node->Son(false)->getKey() << endl;
    else if(node->Son(true)== NULL && node->Son(false) != NULL)
    cout <<"NULL"<<" " <<node->Son(false)->getKey() << endl;
    else if(node->Son(true)!= NULL && node->Son(false) == NULL) 
    cout <<node->Son(true)->getKey()<<" " <<"NULL" << endl;
    else
    cout <<"NULL"<<" " <<"NULL";
    
    if(node->Father() != NULL)
    cout<< " padre: "<< node->Father()->getKey()<< endl;
    else cout << " padre: NULL" << endl;*/
    ////////////////////////////////////////////
    
    if(node->Son(false)!=NULL){
    tmp=RefreshPrettyOrder(node->Son(false),tmp)+1;   
    }
    node->prettyOrder=tmp; tmp++;
    if(node->Son(true)!=NULL)
    tmp=RefreshPrettyOrder(node->Son(true),tmp)+1;
    return tmp;
    
}


